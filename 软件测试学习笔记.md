# 软件测试学习笔记

## 软件测试的心理学和经济学

### 软件测试心理学

要成功的测试一个软件应用，首先需要测试人员有一个正确的态度(attitude)，或者说是正确的心理预期(vision)。

#### 1. 软件测试是为了发现错误

软件测试误区：软件测试是为了证明程序能够正确运行。

软件测试的真正内涵：

**软件测试是为了发现错误而执行程序的过程。**

如果是为了证明程序正确而进行测试，那么就会在潜意识中倾向于实现这个目标而去选择可能较少导致程序失败的测试数据。只有当明确是为了发现错误而去测试时，才有可能更多的发现问题。**能够发现问题的测试才能增加程序的价值。**

软件测试的本质揭示了软件测试是一种违背人性的，破坏性的过程，这也是为什么软件测试有时候会很困难。

#### 2. 软件测试中的成功与不成功

软件测试中对于成功和不成功的定义可能和大多数人的理解是不一样的。所谓成功的测试应该是发现了程序的错误。而如果未能找出错误，则在大多数情况下，则可以被称为是一次不成功的测试。因为软件测试的价值，就是为了发现程序中的错误，而软件中不包含任何错误基本上是不切实际的。

#### 3. 不正确的心理预期带来的效率问题

心理学研究表明，当人们开始一项工作时，如果已经知道它是不可行的或无法实现时，人的表现就会相当糟糕。只有认识到软件测试是发现程序错误的过程，才能使软件测试成为一个可以完成的任务，从而克服这个心理障碍。

而不正确的心理预期还会导致的结果是，经过测试之后，程序即使能够完成预定的功能，仍然隐藏着错误。也就是说可能只是证明了“软件做了其应该做的”，而没有发现另一类错误：“软件做了其不应该做的”，而后一种错误同样是严重的。

### 软件测试经济学

**软件测试无法发现所有的错误。**

#### 黑盒测试

又称为数据驱动的测试或输入/输出驱动的测试。黑盒测试将程序视为一个黑盒子，测试目标与程序的内部机制和结构完全无关，将重点集中放在发现程序不按其规范运行的环境条件。这种测试中测试数据完全来源于软件规范，而不需要了解程序的内部结构。

如果想要通过黑盒测试来发现程序所有可能的错误，则要穷举所有的输入。不仅除了所有的有效输入，还要测试所有可能的无效输入，这在大多数情况下都是不可能的。

#### 白盒测试

又称为逻辑驱动的测试。白盒测试对程序的逻辑结构进行检查，从中获取测试数据。

要想通过白盒测试发现所有可能出现的问题，要穷举所有程序路径，保证每条语句至少执行一次。这对很多程序来说是个天文数字。此外，更要命的一点是，即使能够做到穷举所有路径，程序中仍然可能存在错误，原因有三：

1. 即使穷举路径测试，也不能保证程序符合设计规范。
2. 程序可能因为缺少某些路径而存在问题。
3. 无法暴露对数据敏感的错误。

因此，白盒测试也无法保证发现程序中的所有错误。

### 软件测试的原则

1. 测试用例中的一个必需部分是对预期输出或结果的定义。（没有期望，就没有意外）
2. 程序员应当避免测试自己编写的程序。（编程是建设性的，而测试是破坏性的）
3. 编写软件的组织不应当测试自己编写的软件。
4. 应当彻底检查每个测试的执行结果。
5. 测试用例的编写不仅应当根据有效和预期的输入情况，而且也应当根据无效和未预料到的输入情况。
6. 检查程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”。
7. 应避免测试用例用后即弃，除非软件本身是一个一次性软件。（保留用例，利于回归测试）
8. 计划测试工作时不应默许假定不会发现错误。（要有正确的心理预期）
9. 程序某部分存在更多错误的可能性，与该部分已发现的错误的数量成正比。（错误总是倾向于聚集存在）
10. 软件测试是一项极富创造性、极具智力挑战性的工作。

## 测试用例的设计

测试用例设计所研究的问题可以概括为：

**在所有可能的测试用例中，寻找哪个子集最有可能发现最多的错误。**

### 白盒测试的测试用例设计

#### 路径覆盖

路径覆盖是要做到完全的白盒测试，即将程序中的每一条执行路径都执行到。这在带有循环的程序来说，不太切合实际，所需要的用例可能是个天文数字。

#### 语句覆盖

语句覆盖的原则是将程序中的所有程序语句都至少执行一次。虽然看上去所有的语句都有执行到，但这其实是白盒测试中较弱的准则，如果以语句覆盖的标准去设计测试用例，那么很多类型的错误都无法发现。

#### 判定覆盖

判定覆盖要求必须编写足够多的测试用例，使得每一个判断都至少有一个为真和为假的输出结果，也就是说每条分支路径都至少遍历一次。判定覆盖的条件比语句覆盖更强，但是仍然存在不足。

#### 条件覆盖

条件覆盖要求编写足够多的测试用例以确保将一个判断中的每个条件的所有可能的结果都至少执行一次。

#### 判定/条件覆盖

这种准则要求设计出充足的测试用例，将一个判断中的每个条件的所有可能的结果至少执行一次，将每个判断的所有可能的结果至少执行一次，将每个入口点都至少调用一次。

判断/条件覆盖看上去所有条件的结果都执行到了，但是由于编译器中对于逻辑运算的短路特性，实际上有些特定的条件会屏蔽掉其他的条件。最典型的就是逻辑与和或运算语句，当已经能判断出语句的真假时，后面的语句都会被短路而不再执行了。

#### 多重条件覆盖

该准则要求编写足够多的测试用例，将每个判定中的所有可能的条件和结果的组合，以及所有的入口点都至少执行一次。

多重条件覆盖就是为了出现上面所提的逻辑语句判断中可能出现的条件短路问题。满足多重条件覆盖准则的测试用例集同样满足判定覆盖准则，条件覆盖准则以及判定/条件覆盖准则。

#### 总结

对于每个判断只存在一种条件的程序：（1）将每个判断的所有结果都至少执行一次，（2）将所有的程序入口都至少调用一次。

对于包含多重条件判断的程序，设计足够数量的测试用例，将每个判断的所有可能的条件结果的组合，以及所有的入口点都至少执行一次。

### 黑盒测试的测试用例设计

黑盒测试的主要目标就是基于程序规格说明书找出程序不符合规格说明书的地方。

#### 等价划分

等价划分的黑盒测试方法的目标是设计一个测试用例集合满足如下两个特性：

1. 严格控制测试用例的增加，在保证做到“合理测试”的目标下减少测试用例的数量。
2. 能够覆盖大部分其他可能的测试用例。

第一个特性意味着每个测试用例必须尽可能多的不同的输入情况，以使最大限度地减少测试所需的全部用例的数量。第二个特性意味着应该尽量将程序输入范围进行划分，将其划分为有限数量的等价类，这样就可以合理假设测试这个等价类的一个代表性数据等同于测试该类的其他任何数据。

使用等价划分方法设计测试用例主要包括两个步骤：

1. 确定等价类

   选取每一个输入条件，并将其划分两个或更多的组。等价类有两类，一类是有效等价类，代表对程序的有效输入，另一类无效等价类则是其他任何可能的不正确的输入值。确定等价类有以下原则：

   1. 如果输入跳进啊规定了一个取值范围，那么应该确定一个有效等价类（取值范围内），两个无效等价类（低于取值下限和高于取值上限）
   2. 如果输入条件规定了取值的个数，那么应该确定一个有效类（合理的数量）和两个无效等价类（0或者多于最大数量）
   3. 如果输入条件规定了一个输入值集合，那么应该为每个输入值确定一个有效等价类（在输入值集合内）和一个无效等价类（集合以外的值）
   4. 如果输入条件规定了“必须是的情况”，那么应该确定一个有效等价类（满足条件）和一个无效等价类（不满足条件）

2. 生成测试用例

   生成测试用例可以分为三个步骤：

   1. 为每个等价类设置一个不同的编号
   2. 设计新的测试用例，尽可能多的覆盖那些尚未涵盖的有效等价类，直至覆盖所有有效等价类。
   3. 设计新的测试用例，仅覆盖一个尚未被涵盖的无效等价类，直至所有的无效等价类都被覆盖。



### 边界值分析

所谓边界条件，是指输入和输出等价类那些恰好处于边界或超过边界或处在边界以下的状态。他与等价类划分方法的不同在于：

1. 边界值分析要选择一个或多个元素，使得等价类的每个边界都经过一次测试。
2. 与仅仅关注输入条件不同，还需要考虑从输出（结果空间）设计等价用例。

### 错误猜测
