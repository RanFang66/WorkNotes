# 模块化软件平台测试标准和要求

## 0. 写在前面

### 对软件测试的正确态度

1. 软件测试的定义是：**软件测试是为了发现错误而执行程序的过程。**

   所以在软件测试时的正确心理预期应该是**：要发现错误，而不是要证明程序没问题**。一次成功的软件测试应该是发现程序中的错误，从而增加了程序的价值，而不是没有发现问题。

2. **软件测试无法发现所有的错误。**

   无论是黑盒测试还是白盒测试，都无法保证能检查除所有的软件错误，只能通过设计合理的充分的测试用例来尽量检查可能出现的错误。

### 测试方法的介绍

#### 黑盒测试

又称为数据驱动的测试或输入/输出驱动的测试。黑盒测试将程序视为一个黑盒子，测试目标与程序的内部机制和结构完全无关，将重点集中放在发现程序不按其规范运行的环境条件。这种测试中测试数据完全来源于软件规范，而不需要了解程序的内部结构。

**白盒测试**

又称为逻辑驱动的测试。白盒测试对程序的逻辑结构进行检查，从中获取测试数据。

#### 增量测试与非增量测试

当对软件进行分模块的单元测试时，可以选择增量测试和非增量测试两种方式。

非增量测试：单独的测试每一个模块，为每一个模块编写驱动模块（用来将测试用例传输到被测模块中）和桩模块（用来模拟被测模块调用的其他模块）。

增量测试：不同于独立的测试每一个模块，增量测试首先将下一个要测试的模块组装到前面已经测试过的模块集合中去。增量测试又分为自顶向下测试于自底向上测试，这两者的区别是模块测试进行的方向不同。

## 1. 调试开关和调试接口

程序中可以设定一些调试接口，用于打印一些调试或者出错信息。这些调试代码，只在代码调试阶段有用，因此可以设置调试开关，以方便的控制这些调试函数是否使用。

```c
#define __DEBUG 	// 总调试开关

#ifdef __DEBUG
#define DEBUG(format, ...) printf("File: %s, Line: %05d, Func: %s..."format"\n", __FILE__, __LINE__, __func__, ##__VA_ARGS__)
#define ASSERT(expr)	assert(expr)	// 需要包含assert.h

#else
#define DEBUG(format, ...)
#define ASSERT(expr)	
#endif
```

以上通过宏定义的方式设置了调试开关__\__DEBUG__，当该宏定义存在时，程序内就可以使用DEBUG()函数打印调试信息，同时可以使用ASSERT()函数进行断言调试。当不需要调试时，将该宏定义注释，所有的调试接口将不再起作用。以上定义的是整个系统的总调试开关和调试接口，如果某个模块有单独的调试需求或者其他调试接口需要，可以单独定义一个模块调试开关和一些模块调试的接口。例如调试SPI模块时需要其他调试接口，可以：

``` c
#define __SPI_DEBUG

#ifdef __SPI_DEBUG
// Your definition for SPI debug
#else
//
#endif
```

__关于printf函数的重定向__

在调试程序时，一般可以通过重定向printf函数进行调试信息的打印。最常用的方式是将printf函数重定向到串口上，这样就能够在程序运行时通过串口将程序运行调试信息输出到PC上。对于printf函数在串口上的重定向（重定向到其他外设同理），在STM32上的做法为：

1. 实现UART底层驱动（通过UART发送字节函数）。
2. 用实现的UART发送字节驱动函数重写fputc函数。
3. 使用重定向后的printf函数打印调试信息。

DSP C2000上的做法为：

参考：[TI:Tips for Using Printf](https://software-dl.ti.com/ccs/esd/documents/sdto_cgt_tips_for_using_printf.html)

> ## Using printf() to output to a user-defined device
>
> You can install a user-defined driver so that you can use the sophisticated buffering of the high-level C I/O functions on an arbitrary device, such as a UART.
>
> The user-defined driver will not use the C I/O interface to communicate with the debugger; the driver will need to provide some other means of output, such as controlling a peripheral.
>
> 1. Get/write a device driver for outputting data from the UART (or whatever interface you choose).
> 2. Write the low-level functions as described in Chapter 8.2 The C I/O Functions of the C Compiler User's Guide.
> 3. Call `add_device` to add your functions to the stream table (i.e. in addition to stdin, stdout, stderr).
> 4. Open your stream.
> 5. Redirect your stream to stdout using `freopen`.
> 6. Specify what buffering is to be used for your stream by calling `setvbuf`.

```c
ret_val = add_device("uart", _SSA,
                     uart_open,
             uart_close,
             uart_read,
             uart_write,
             uart_lseek,
             uart_unlink,
             uart_rename);

fid = fopen("uart", "w");
freopen("uart:", "w", stdout);     // redirect stdout to uart
setvbuf(stdout, NULL, _IONBF, 0);  // turn off buffering for stdout
printf("Hello world!\r\n");
```

## 2. 测试用例的设计

测试用例的核心问题可以概括为：

**在所有可能的测试用例中，哪个子集最有可能发现最多的错误。**

可以选用的测试用例设计策略是： 先使用黑盒测试方法来设计测试用例，然后视情况使用白盒测试方法来设计补充的测试用例。

### 黑盒测试用例的设计

考虑使用等价划分的用例设计方法

等价划分的黑盒测试方法的目标是设计一个测试用例集合满足如下两个特性：

1. 严格控制测试用例的增加，在保证做到“合理测试”的目标下减少测试用例的数量。
2. 能够覆盖大部分其他可能的测试用例。

第一个特性意味着每个测试用例必须尽可能多的不同的输入情况，以使最大限度地减少测试所需的全部用例的数量。第二个特性意味着应该尽量将程序输入范围进行划分，将其划分为有限数量的等价类，这样就可以合理假设测试这个等价类的一个代表性数据等同于测试该类的其他任何数据。

使用等价划分方法设计测试用例主要包括两个步骤：

1. 确定等价类

   选取每一个输入条件，并将其划分两个或更多的组。等价类有两类，一类是有效等价类，代表对程序的有效输入，另一类无效等价类则是其他任何可能的不正确的输入值。确定等价类有以下原则：

   1. 如果输入跳进啊规定了一个取值范围，那么应该确定一个有效等价类（取值范围内），两个无效等价类（低于取值下限和高于取值上限）
   2. 如果输入条件规定了取值的个数，那么应该确定一个有效类（合理的数量）和两个无效等价类（0或者多于最大数量）
   3. 如果输入条件规定了一个输入值集合，那么应该为每个输入值确定一个有效等价类（在输入值集合内）和一个无效等价类（集合以外的值）
   4. 如果输入条件规定了“必须是的情况”，那么应该确定一个有效等价类（满足条件）和一个无效等价类（不满足条件）

2. 生成测试用例

   生成测试用例可以分为三个步骤：

   1. 为每个等价类设置一个不同的编号
   2. 设计新的测试用例，尽可能多的覆盖那些尚未涵盖的有效等价类，直至覆盖所有有效等价类。
   3. 设计新的测试用例，仅覆盖一个尚未被涵盖的无效等价类，直至所有的无效等价类都被覆盖。

同时要结合一定的边界值分析：所谓边界条件，是指输入和输出等价类那些恰好处于边界或超过边界或处在边界以下的状态。他与等价类划分方法的不同在于：

1. 边界值分析要选择一个或多个元素，使得等价类的每个边界都经过一次测试。
2. 与仅仅关注输入条件不同，还需要考虑从输出（结果空间）设计等价用例。

具体设计方法是：

设计测试用例时应该包含边界值得情况（输入最大值和最小值的情况），同时包含刚刚超出边界的临界情况（比最小值略小一点和比最大值略大一点）

### 白盒测试用例的设计

在做完黑盒测试之后，可以根据需要补充适当的白盒测试用例。在做白盒测试时，需要通过调试手段去观察程序运行的内部过程和内部变量的情况，具体可以通过仿真或者输出调试信息的方式。

最完备的白盒测试是路径测试，及测试程序所有可能的执行路径，但是这对于带有循环结构的程序工作量可能是个天文数字。因此一般采用多重条件覆盖的测试原则。该原则要求编写足够多的测试用例，将每个判定中的所有可能的条件和结果的组合，以及所有的入口点都至少执行一次。

对于每个判断只存在一种条件的程序：（1）将每个判断的所有结果都至少执行一次，（2）将所有的程序入口都至少调用一次。

对于包含多重条件判断的程序，设计足够数量的测试用例，将每个判断的所有可能的条件结果的组合，以及所有的入口点都至少执行一次。

## 3. 模块测试方法的选择

针对模块测试可以选择增量测试或者非增量测试。从实际效果来看，选择增量测试的效果较好。结合模块化软件开发的流程，对于驱动层和公共服务库模块的测试是独立的，与其他模块没有联系。对于通用模块层以及功能逻辑层模块的测试就需要用到经过测试后的驱动层以及公共服务库模块，这时就属于增量测试。

## 4. 测试程序的编写

测试过程中需要编写相应的单元测试程序，单元测试程序的主要功能是调用需要测试的模块，并且传入准备号的测试数据，然后将结果以某种形式呈现出来（一般通过仿真器或者打印信息），有时候还需要我们编写相应的测试脚本用来向程序输入数据。

单元测试程序应当放在工程中的一个独立文件夹uni_test中，每个模块的单元测试程序都有一个单独的程序文件，文件名为"模块名_test.c"。整个uni_test文件夹中包含一个uni_test.h头文件，该头文件中包含所有的测试函数或者变量的声明。

