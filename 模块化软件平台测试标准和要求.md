# 模块化软件平台测试标准和要求

## 0. 写在前面

### 对软件测试的正确态度

1. 软件测试的定义是：**软件测试是为了发现错误而执行程序的过程。**

   所以在软件测试时的正确心理预期应该是**：要发现错误，而不是要证明程序没问题**。一次成功的软件测试应该是发现程序中的错误，从而增加了程序的价值，而不是没有发现问题。

2. **软件测试无法发现所有的错误。**

   无论是黑盒测试还是白盒测试，都无法保证能检查除所有的软件错误，只能通过设计合理的充分的测试用例来尽量检查可能出现的错误。

### 测试方法的介绍

#### 黑盒测试

又称为数据驱动的测试或输入/输出驱动的测试。黑盒测试将程序视为一个黑盒子，测试目标与程序的内部机制和结构完全无关，将重点集中放在发现程序不按其规范运行的环境条件。这种测试中测试数据完全来源于软件规范，而不需要了解程序的内部结构。

**白盒测试**

又称为逻辑驱动的测试。白盒测试对程序的逻辑结构进行检查，从中获取测试数据。

#### 增量测试与非增量测试

当对软件进行分模块的单元测试时，可以选择增量测试和非增量测试两种方式。

非增量测试：单独的测试每一个模块，为每一个模块编写驱动模块（用来将测试用例传输到被测模块中）和桩模块（用来模拟被测模块调用的其他模块）。

增量测试：不同于独立的测试每一个模块，增量测试首先将下一个要测试的模块组装到前面已经测试过的模块集合中去。增量测试又分为自顶向下测试于自底向上测试，这两者的区别是模块测试进行的方向不同。

## 1. 调试开关和调试接口

程序中可以设定一些调试接口，用于打印一些调试或者出错信息。这些调试代码，只在代码调试阶段有用，因此可以设置调试开关，以方便的控制这些调试函数是否使用。

```c
#define __DEBUG 	// 总调试开关

#ifdef __DEBUG
#define DEBUG(format, ...) printf("File: %s, Line: %05d, Func: %s..."format"\n", __FILE__, __LINE__, __func__, ##__VA_ARGS__)
#define ASSERT(expr)	assert(expr)	// 需要包含assert.h

#else
#define DEBUG(format, ...)
#define ASSERT(expr)	
#endif
```

以上通过宏定义的方式设置了调试开关__\__DEBUG__，当该宏定义存在时，程序内就可以使用DEBUG()函数打印调试信息，同时可以使用ASSERT()函数进行断言调试。当不需要调试时，将该宏定义注释，所有的调试接口将不再起作用。以上定义的是整个系统的总调试开关和调试接口，如果某个模块有单独的调试需求或者其他调试接口需要，可以单独定义一个模块调试开关和一些模块调试的接口。例如调试SPI模块时需要其他调试接口，可以：

``` c
#define __SPI_DEBUG

#ifdef __SPI_DEBUG
// Your definition for SPI debug
#else
//
#endif
```

__关于printf函数的重定向__

在调试程序时，一般可以通过重定向printf函数进行调试信息的打印。最常用的方式是将printf函数重定向到串口上，这样就能够在程序运行时通过串口将程序运行调试信息输出到PC上。对于printf函数在串口上的重定向（重定向到其他外设同理），在STM32上的做法为：

1. 实现UART底层驱动（通过UART发送字节函数）。
2. 用实现的UART发送字节驱动函数重写fputc函数。
3. 使用重定向后的printf函数打印调试信息。

DSP C2000上的做法为：

参考：[TI:Tips for Using Printf](https://software-dl.ti.com/ccs/esd/documents/sdto_cgt_tips_for_using_printf.html)

> ## Using printf() to output to a user-defined device
>
> You can install a user-defined driver so that you can use the sophisticated buffering of the high-level C I/O functions on an arbitrary device, such as a UART.
>
> The user-defined driver will not use the C I/O interface to communicate with the debugger; the driver will need to provide some other means of output, such as controlling a peripheral.
>
> 1. Get/write a device driver for outputting data from the UART (or whatever interface you choose).
> 2. Write the low-level functions as described in Chapter 8.2 The C I/O Functions of the C Compiler User's Guide.
> 3. Call `add_device` to add your functions to the stream table (i.e. in addition to stdin, stdout, stderr).
> 4. Open your stream.
> 5. Redirect your stream to stdout using `freopen`.
> 6. Specify what buffering is to be used for your stream by calling `setvbuf`.

```c
ret_val = add_device("uart", _SSA,
                     uart_open,
             uart_close,
             uart_read,
             uart_write,
             uart_lseek,
             uart_unlink,
             uart_rename);

fid = fopen("uart", "w");
freopen("uart:", "w", stdout);     // redirect stdout to uart
setvbuf(stdout, NULL, _IONBF, 0);  // turn off buffering for stdout
printf("Hello world!\r\n");
```

## 2. 模块单元测试

### 测试用例的设计

测试用例的核心问题可以概括为：

**在所有可能的测试用例中，哪个子集最有可能发现最多的错误。**

我们选用的测试用例设计策略是： 先使用黑盒测试方法来设计测试用例，然后视情况使用白盒测试方法来设计补充的测试用例。

白盒测试

